1.信号与槽的原理
帮助里有个图connect

2.信号和槽的链接类型
Qt::ConnectionType枚举--connect最后一个参数
1)DirectConnection,直接链接--如C中的函数调用，已有信号，立马调用槽，注意共享数据的竞争
2)QueueDConnection,队列链接--事件循环，线程间的槽链接
3)BlockingQueuedConnection,阻塞式队列链接--只能用一线程间链接，同一个信号可能会死锁
4)AutoConnection,自动链接--default--一般用这个，不填，让Qt选择链接方式

信号与槽的使用场景
大概4种使用信号与槽的方式：
1)仅适用Qt类库种的信号与槽
2)使用Qt类库的预定义信号，实现自己的槽来响应那些信号
3)使用Qt类库的预定义槽来响应我们自定义的信号
4)自己定义信号与槽，自己信号连接自己的槽

信号与槽的使用步骤：
1)从QObject类或它的派生类继承
2)类开头，使用Q_OBJEC宏
3)使用signals关键字声明信号--moc会生成这些函数，自己写了同名函数，会报错
4)使用slots关键字声明槽，必须实现函数
5)对象状态改变时emit signals();	//发送信号
6)QObject::connect()连接信号与槽

经验
1)信号与对象的特定状态对应
2)一个信号可以和一个槽连接
3)一个信号可以连接多个槽
4)一个槽可以接收多个信号
5)槽的参数必须和信号类型匹配
6)槽的参数个数可以少于但不能多于信号的参数个数
7)连接信号和槽是基于字符串，不需要考虑访问控制--如public-protect的访问限制不用管
8)信号与槽的链接是动态的，试运行时发生的--程序运行时才报错，如信号槽名字写错了
9)信号与槽的链接是可以断开的，使用disconnect()函数
10)信号可以链接信号，但槽不能连接槽
11)信号与槽可以分属处于不同的线程环境中的对象
12)跨线程的信号与槽的链接，多数通过QApplication::postEvent()完成槽的调用，因此槽的调用一般发生在槽所属对象所在的线程环境中--事件循环，来调用槽
13)QObject::sender()可以获取发送信号的对象--破坏了面向对象的方式，有风险；调用sender获取到被干掉的线程对象。
